整理记录一下各种背包问题的模型。
**有些地方或者代码使用的是我之前的笔记，所以可能分析时是dp数组，代码中是f数组，但这影响很小。**
# 01背包
dp[i][j] 表示从前i个物品中选，且体积不超过j的所有选法中所获价值最大的
状态转移： 
**选择第i个物品：dp[i][j] = dp[i-1][j-v[i]] + w[i]**
**不选第i个物品： dp[i][j] = dp[i-1][j]**
```
 for(int i = 1; i<=n; i++){
        int w,v;
        cin>>v>>w;
        for(int j = 1; j<=m; j++){
            dp[i][j] = dp[i-1][j];
            if(j>=v)dp[i][j] = max(dp[i][j], dp[i-1][j-v]+w);
        }
    }
```

## 01背包空间优化
我们发现状态转移时只用到了第i-1层的状态，所以我们可以使用滚动数组把第一维优化掉
注意两点：
**1.为什么反向遍历？**
正向遍历的话，这一层前面更新的值会覆盖掉上一层的值，导致后面的更新出错
**2.为什么j不需要到走到1**
如果j < v的话，那么dp[j] = max(0,dp[k]) = dp[k] ，dp[k] 没有得到更新，所以可以直接跳出循环
```
for(int i = 1; i<=n; i++){
        int w,v;
        cin>>v>>w;
        for(int j = m; j>=v; j--){
            dp[j] = max(dp[j], dp[j-v]+w);
        }
    }
```

# 完全背包
与01背包不同的是，对于完全背包，每个物品可以拿任意个，所以状态表示可以和01背包一样，只不过在状态转移时我们需要枚举当前第i个物品拿几个，代码：
```
for(int i = 1; i<=n ;i++)
        for(int j = 0; j<=m ;j++)
            for(int k = 0; k*v[i]<=j ;k++)
                f[i][j] = max(f[i][j],f[i-1][j-k*v[i]]+k*w[i]);
```
## 完全背包优化
与01背包一样的思路，只不过由于物品是无限个，所以我们不用逆序，而是考虑用第i层中前面体积较小的背包来更新后面的状态，因为第i个物品在体积较小的背包里面可能已经拿了多个。
推导：
**f[i , j ] = max( f[i-1,j] , f[i-1,j-v]+w ,  f[i-1,j-2 * v]+2 * w , f[i-1,j-3 * v]+3 * w , ...)**
**f[i , j-v]= max(                      f[i-1,j-v]   ,  f[i-1,j-2 * v] + w , f[i-1,j-2 * v]+2 * w , ...)**
比较两式：
**dp[i][j] = max(dp[i-1][j], dp[i,j-v]+w);**(从这个式子也可以看出来我们应该使用第i层进行更新）
可以发现， 正序： 对应第i层。
逆序： 对应第i-1层。
```
for(int i = 1; i<=n; i++){
        cin>>v>>w;
        for(int j = v; j<=m; j++){
            dp[j] = max(dp[j],dp[j-v]+w);
        }
    }
```
# ...
