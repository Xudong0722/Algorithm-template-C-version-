整理记录一下各种背包问题的模型。

# 01背包
dp[i][j] 表示从前i个物品中选，且体积不超过j的所有选法中所获价值最大的
状态转移： 
**选择第i个物品：dp[i][j] = dp[i-1][j-v[i]] + w[i]**
**不选第i个物品： dp[i][j] = dp[i-1][j]**
```
 for(int i = 1; i<=n; i++){
        int w,v;
        cin>>v>>w;
        for(int j = 1; j<=m; j++){
            dp[i][j] = dp[i-1][j];
            if(j>=v)dp[i][j] = max(dp[i][j], dp[i-1][j-v]+w);
        }
    }
```

# 01背包空间优化
我们发现状态转移时只用到了第i-1层的状态，所以我们可以使用滚动数组把第一维优化掉
注意两点：
**1.为什么反向遍历？**
正向遍历的话，这一层前面更新的值会覆盖掉上一层的值，导致后面的更新出错
**2.为什么j不需要到走到1**
如果j < v的话，那么dp[j] = max(0,dp[k]) = dp[k] ，dp[k] 没有得到更新，所以可以直接跳出循环
```
for(int i = 1; i<=n; i++){
        int w,v;
        cin>>v>>w;
        for(int j = m; j>=v; j--){
            dp[j] = max(dp[j], dp[j-v]+w);
        }
    }
```

# 完全背包



# ...
